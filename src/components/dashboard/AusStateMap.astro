---
interface Props {
  counts?: Record<string, number>;
  fetchUrl?: string;
  svgUrl?: string;
  title?: string;
  class?: string;
  aspect?: string; // optional, eg "16/10"
}

const {
  counts = { NSW:152, QLD:201, VIC:134, SA:37, WA:65, TAS:12, NT:7, ACT:19 },
  fetchUrl = "",
  svgUrl = "/images/maps/au-states.svg",
  title = "Visitors by State",
  class: className = "",
  aspect = "11/9",
} = Astro.props;

const uid = `au-map-${Math.random().toString(36).slice(2,9)}`;
const COUNTS_ATTR = encodeURIComponent(JSON.stringify(counts));
---

<section class={`au-map ${className}`} id={uid} style={`--au-aspect:${aspect}`}>
  <div class="grid">
    <div class="l-8 m-8 s-12">
      <div class="au-map__wrap">
        <div
          class="au-map__svg"
          aria-label="Australia states map"
          data-svg-url={svgUrl}
          data-counts={COUNTS_ATTR}
          data-fetch-url={fetchUrl || undefined}
        ></div>

        <div class="au-map__legend" aria-hidden="true"></div>
        <output class="au-map__tooltip" role="status" aria-live="polite"></output>
      </div>
    </div>
    <div class="l-4 m-4 s-12">
      <div class="panel">
      {title && <h2 class="au-map__title"><i class="wt-pin"></i> {title}</h2>}
      <ol class="au-map__list"></ol>
    </div></div>
  </div>

<script is:inline data-root={uid}>
(() => {
  const rootId = document.currentScript?.dataset?.root;
  const root   = rootId ? document.getElementById(rootId) : null;
  if (!root) return;

  // ─────────────────────────────────────────────────────────────
  // THEME: set your brand colors here
  // mode: "gradient" | "hsl" | "perState"
  const THEME = {
    mode: "gradient",

    // Hover/focus highlight + outline/border
    hoverFill: "#00AA77",
    strokeHex: "#374151",

    // If mode === "gradient"
    rampStart: "#78bb36",   // light brand tint
    rampEnd:   "#00553d",   // brand primary

    // If mode === "hsl"
    hue: 200,  // brand hue (0-360)
    sat: 70,   // % saturation
    lightMin: 52, // darkest (higher count)
    lightMax: 90, // lightest (lower count)

    // If mode === "perState"
    perState: {
      NSW:"#0047AB", QLD:"#1E88E5", VIC:"#1565C0", SA:"#0EA5E9",
      WA:"#0891B2", TAS:"#22D3EE", NT:"#38BDF8", ACT:"#60A5FA"
    }
  };
  // ─────────────────────────────────────────────────────────────

  const wrap   = root.querySelector('.au-map__wrap');
  const el     = root.querySelector('.au-map__svg');
  const legend = root.querySelector('.au-map__legend');
  const tip    = root.querySelector('.au-map__tooltip');
  const listEl = root.querySelector('.au-map__list');

  const NAMES = {
    WA:"Western Australia", NT:"Northern Territory", QLD:"Queensland",
    SA:"South Australia", NSW:"New South Wales", ACT:"Australian Capital Territory",
    VIC:"Victoria", TAS:"Tasmania"
  };

  // Helpers
  const normCounts = (base) => {
    const out = {NSW:0,QLD:0,VIC:0,SA:0,WA:0,TAS:0,NT:0,ACT:0};
    try {
      const obj = typeof base === 'string' ? JSON.parse(decodeURIComponent(base)||'{}') : (base||{});
      Object.keys(obj).forEach(k => { const c = k.toUpperCase(); if (c in out) out[c] = Number(obj[k]||0); });
    } catch {}
    return out;
  };
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const hexToRgb = h => h.replace('#','').match(/.{2}/g).map(x=>parseInt(x,16));
  const rgbToHex = ([r,g,b]) => '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
  const lerp = (a,b,t)=>a+(b-a)*t;
  const lerpHex = (a,b,t) => {
    const A = hexToRgb(a), B = hexToRgb(b);
    return rgbToHex([lerp(A[0],B[0],t), lerp(A[1],B[1],t), lerp(A[2],B[2],t)].map(Math.round));
  };
  const hslToHex = (h, sPct, lPct) => {
    const s = sPct / 100, l = lPct / 100;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = ((h % 360) + 360) % 360 / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let r=0,g=0,b=0;
    if      (hp < 1) { r=c; g=x; b=0; }
    else if (hp < 2) { r=x; g=c; b=0; }
    else if (hp < 3) { r=0; g=c; b=x; }
    else if (hp < 4) { r=0; g=x; b=c; }
    else if (hp < 5) { r=x; g=0; b=c; }
    else             { r=c; g=0; b=x; }
    const m = l - c/2;
    const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  };

  // Base colour by scheme
  const baseColor = (code, v, max) => {
    if (THEME.mode === "perState") {
      return THEME.perState[code] || "#cccccc";
    }
    const t = clamp01(v / Math.max(1, max));
    if (THEME.mode === "hsl") {
      const L = THEME.lightMax - t * (THEME.lightMax - THEME.lightMin);
      return hslToHex(THEME.hue, THEME.sat, L);
    }
    // default "gradient"
    return lerpHex(THEME.rampStart, THEME.rampEnd, t);
  };
  const legendEnds = (max) => {
    if (THEME.mode === "perState") return ["#f1f5f9", THEME.hoverFill];
    return [baseColor("NSW", 0, max), baseColor("NSW", max, max)]; // any code works
  };

  async function init() {
    if (!el) return;
    const svgUrl   = el.dataset.svgUrl || 'images/maps/au-states.svg';
    const fetchUrl = el.dataset.fetchUrl || '';
    const fallbackCounts = normCounts(el.dataset.counts);

    async function loadCounts(){
      if (!fetchUrl) return fallbackCounts;
      try { const r = await fetch(fetchUrl, { cache:'no-store' }); return normCounts(await r.json()); }
      catch { return fallbackCounts; }
    }

    const [svgRes, counts] = await Promise.all([ fetch(svgUrl).catch(()=>null), loadCounts() ]);
    if (!svgRes || !svgRes.ok) { el.textContent = 'Map failed to load (check path)'; return; }
    const svgText = await svgRes.text();

    el.innerHTML = svgText;
    const svg = el.querySelector('svg');
    if (!svg) { el.textContent = 'Invalid SVG'; return; }
    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    // Build node map from IDs like AU-NSW, AU-QLD, ...
    const nodeByCode = {};
    svg.querySelectorAll('[id^="AU-"]').forEach(node => {
      const code = node.id.replace(/^AU-/, '');
      if (NAMES[code]) nodeByCode[code] = node;
    });

    // Sidebar list (sorted desc)
    const pairs = Object.entries(counts).filter(([k]) => NAMES[k]);
    pairs.sort((a,b) => (b[1]||0) - (a[1]||0));
    if (listEl) {
      listEl.innerHTML = pairs.map(([code,val]) =>
        `<li class="au-map__item" data-code="${code}">
          <span class="code">${code}</span>
          <span class="name">${NAMES[code]}</span>
          <span class="val">${Number(val||0).toLocaleString()}</span>
        </li>`).join('');
    }

    const max = Math.max(...Object.values(counts), 1);
    const hoverFill = THEME.hoverFill;
    const strokeHex = THEME.strokeHex;

    function clearActive() {
      svg.querySelectorAll('[data-code].is-active').forEach(n => n.classList.remove('is-active'));
      listEl?.querySelectorAll('.au-map__item.is-active').forEach(n => n.classList.remove('is-active'));
    }
    function highlight(code) {
      clearActive();
      svg.querySelector(`[data-code="${code}"]`)?.classList.add('is-active');
      listEl?.querySelector(`.au-map__item[data-code="${code}"]`)?.classList.add('is-active');
    }
    function posTipAtPointer(e) {
      if (!wrap) return;
      const rect = wrap.getBoundingClientRect();
      tip.style.left = `${(e.clientX - rect.left) + 10}px`;
      tip.style.top  = `${(e.clientY - rect.top) + 10}px`;
    }
    function posTipAtNode(node) {
      if (!wrap) return;
      const rw = wrap.getBoundingClientRect();
      const r  = node.getBoundingClientRect();
      tip.style.left = `${((r.left + r.right)/2 - rw.left) + 10}px`;
      tip.style.top  = `${((r.top + r.bottom)/2 - rw.top) + 10}px`;
    }
    const showTip = (text) => { if (!tip) return; tip.textContent = text; tip.style.opacity='1'; tip.style.visibility='visible'; };
    const hideTip = () => { if (!tip) return; tip.style.opacity='0'; tip.style.visibility='hidden'; };

    // Color & wire states
    Object.entries(nodeByCode).forEach(([code, top]) => {
      const val       = counts[code] || 0;
      const baseFill  = baseColor(code, val, max);
      top.setAttribute('data-code', code);

      const targets = [top, ...top.querySelectorAll('path,polygon,polyline,rect,circle,ellipse')];
      targets.forEach(t => {
        t.setAttribute('fill',  baseFill);
        t.setAttribute('stroke', strokeHex);
        t.setAttribute('stroke-width', '1.2');
        t.style.fill = baseFill;
        t.style.stroke = strokeHex;
        t.style.strokeWidth = '1.2';
        t.style.transition = 'fill .15s ease';
        t.style.pointerEvents = 'auto';
      });

      // a11y
      top.setAttribute('tabindex', '0');
      top.setAttribute('role', 'img');
      top.setAttribute('aria-label', `${NAMES[code]}: ${val.toLocaleString()}`);

      // interactions (pure hex)
      const onEnter = (e) => {
        highlight(code);
        targets.forEach(t => { t.style.fill = hoverFill; t.setAttribute('fill', hoverFill); });
        showTip(`${NAMES[code]}: ${val.toLocaleString()}`);
        if (e && 'clientX' in e) posTipAtPointer(e); else posTipAtNode(top);
      };
      const onMove  = (e) => { if (e && 'clientX' in e) posTipAtPointer(e); };
      const onLeave = () => {
        clearActive();
        hideTip();
        const back = baseColor(code, val, max);
        targets.forEach(t => { t.style.fill = back; t.setAttribute('fill', back); });
      };

      top.addEventListener('pointerenter', onEnter);
      top.addEventListener('pointermove',  onMove);
      top.addEventListener('pointerleave', onLeave);
      top.addEventListener('focus',  () => onEnter(null));
      top.addEventListener('blur',   onLeave);
    });

    // Sidebar → map hover
    listEl?.querySelectorAll('.au-map__item').forEach(li => {
      const code = li.getAttribute('data-code');
      li.addEventListener('pointerenter', () => {
        const node = svg.querySelector(`[data-code="${code}"]`);
        if (!node) return;
        const val = counts[code] || 0;
        const targets = [node, ...node.querySelectorAll('path,polygon,polyline,rect,circle,ellipse')];
        highlight(code);
        targets.forEach(t => { t.style.fill = hoverFill; t.setAttribute('fill', hoverFill); });
        showTip(`${NAMES[code]}: ${Number(val).toLocaleString()}`);
        posTipAtNode(node);
      });
      li.addEventListener('pointerleave', () => {
        const node = svg.querySelector(`[data-code="${code}"]`);
        if (!node) return;
        const val = counts[code] || 0;
        const back = baseColor(code, val, max);
        const targets = [node, ...node.querySelectorAll('path,polygon,polyline,rect,circle,ellipse')];
        targets.forEach(t => { t.style.fill = back; t.setAttribute('fill', back); });
        clearActive(); hideTip();
      });
    });

    // Legend gradient that matches your ramp
    if (legend) {
      const [leftCol, rightCol] = legendEnds(max);
      legend.innerHTML =
        `<span>0</span>
         <span class="swatch" style="display:inline-block;width:64px;height:12px;vertical-align:-2px;margin:0 .5rem;background:linear-gradient(to right, ${leftCol}, ${rightCol});"></span>
         <span>${max.toLocaleString()}</span>`;
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>


  
</section>

 
