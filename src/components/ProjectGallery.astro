---
/** Props:
 *  images: [{ url, alt?, caption? }]
 *  hoverCaptions?: boolean  // default false; set true to show overlay on hover instead of always
 */
interface Img { url: string; alt?: string; caption?: string }
const { images = [], hoverCaptions = false } = Astro.props as { images: Img[], hoverCaptions?: boolean };
const many = images.length > 1;
---

{images.length ? (
  <div class={`pg${hoverCaptions ? ' pg--hover' : ''}`} aria-roledescription="carousel" tabindex="0">
    <div class="pg-viewport">
      <div class="pg-track" style={`width:${images.length * 100}%`}>
        {images.map((img, i) => (
          <figure
            class={`pg-slide${i === 0 ? ' is-active' : ''}`}
            id={`slide-${i}`}
            aria-hidden={i !== 0}
            style={`width:${100 / images.length}%`}
          >
            <img
              src={img.url}
              alt={img.alt ?? ''}
              loading={i === 0 ? 'eager' : 'lazy'}
              decoding={i === 0 ? 'sync' : 'async'}
            />
            {(img.alt || img.caption) && (
              <figcaption class="pg-cap">
                {img.alt && <div class="cap-title">{img.alt}</div>}
                {img.caption && <div class="cap-sub">{img.caption}</div>}
              </figcaption>
            )}
          </figure>
        ))}
      </div>
    </div>

    {many && (
      <>
        <button class="pg-nav pg-prev" aria-label="Previous image"><span aria-hidden="true">‹</span></button>
        <button class="pg-nav pg-next" aria-label="Next image"><span aria-hidden="true">›</span></button>

        <div class="pg-dots" role="tablist" aria-label="Slide dots">
          {images.map((_, i) => (
            <button
              class={`pg-dot${i === 0 ? ' is-active' : ''}`}
              role="tab"
              aria-controls={`slide-${i}`}
              aria-selected={i === 0}
              aria-label={`Go to slide ${i + 1}`}
              data-index={i}
            />
          ))}
        </div>
      </>
    )}
  </div>
) : null}

 

<script is:inline>
  (function () {
    var s = document.currentScript;
    if (!s) return;
    var root = s.previousElementSibling;
    while (root && !(root.classList && root.classList.contains('pg'))) {
      root = root.previousElementSibling;
    }
    if (!root) return;

    var track = root.querySelector('.pg-track');
    var slides = Array.prototype.slice.call(root.querySelectorAll('.pg-slide'));
    var dots = Array.prototype.slice.call(root.querySelectorAll('.pg-dot'));
    var prev = root.querySelector('.pg-prev');
    var next = root.querySelector('.pg-next');

    var n = slides.length;
    if (!track || n <= 1) return updateArrows(0);

    var i = 0;

    function go(newIndex) {
      i = Math.max(0, Math.min(n - 1, newIndex));
      var pct = -(i * (100 / n));
      track.style.transform = 'translateX(' + pct + '%)';

      slides.forEach(function (s, idx) {
        if (idx === i) {
          s.classList.add('is-active');
          s.setAttribute('aria-hidden', 'false');
        } else {
          s.classList.remove('is-active');
          s.setAttribute('aria-hidden', 'true');
        }
      });

      dots.forEach(function (d, idx) {
        d.classList.toggle('is-active', idx === i);
        d.setAttribute('aria-selected', String(idx === i));
      });

      updateArrows(i);
    }

    function updateArrows(idx) {
      if (prev) {
        prev.setAttribute('aria-hidden', String(idx === 0));
        if (idx === 0) prev.setAttribute('disabled', 'true'); else prev.removeAttribute('disabled');
      }
      if (next) {
        next.setAttribute('aria-hidden', String(idx === n - 1));
        if (idx === n - 1) next.setAttribute('disabled', 'true'); else next.removeAttribute('disabled');
      }
    }

    prev && prev.addEventListener('click', function () { go(i - 1); });
    next && next.addEventListener('click', function () { go(i + 1); });
    dots.forEach(function (d) {
      d.addEventListener('click', function () {
        var idx = Number(d.getAttribute('data-index')) || 0;
        go(idx);
      });
    });

    // Keyboard
    root.addEventListener('keydown', function (e) {
      if (e.key === 'ArrowLeft') { e.preventDefault(); go(i - 1); }
      if (e.key === 'ArrowRight') { e.preventDefault(); go(i + 1); }
      if (e.key === 'Home') { e.preventDefault(); go(0); }
      if (e.key === 'End') { e.preventDefault(); go(n - 1); }
    });

    // Basic swipe
    var startX = 0, touching = false;
    root.addEventListener('pointerdown', function (e) { touching = true; startX = e.clientX; });
    root.addEventListener('pointerup', function (e) {
      if (!touching) return;
      var dx = e.clientX - startX;
      if (Math.abs(dx) > 40) go(i + (dx < 0 ? 1 : -1));
      touching = false;
    });

    updateArrows(0);
  })();
</script>
